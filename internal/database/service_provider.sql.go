// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: service_provider.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countServiceProviders = `-- name: CountServiceProviders :one
SELECT count(*) FROM service_providers
`

func (q *Queries) CountServiceProviders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countServiceProviders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSMPPCredential = `-- name: CreateSMPPCredential :one
INSERT INTO sp_credentials (
    service_provider_id,
    protocol,
    status,
    system_id,
    password_hash,
    bind_type,
    http_config
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, service_provider_id, protocol, status, system_id, password_hash, bind_type, api_key_hash, api_key_identifier, http_config, created_at, updated_at, routing_group_id
`

type CreateSMPPCredentialParams struct {
	ServiceProviderID int32   `json:"serviceProviderId"`
	Protocol          string  `json:"protocol"`
	Status            string  `json:"status"`
	SystemID          *string `json:"systemId"`
	PasswordHash      *string `json:"passwordHash"`
	BindType          *string `json:"bindType"`
	HttpConfig        []byte  `json:"httpConfig"`
}

func (q *Queries) CreateSMPPCredential(ctx context.Context, arg CreateSMPPCredentialParams) (SpCredential, error) {
	row := q.db.QueryRow(ctx, createSMPPCredential,
		arg.ServiceProviderID,
		arg.Protocol,
		arg.Status,
		arg.SystemID,
		arg.PasswordHash,
		arg.BindType,
		arg.HttpConfig,
	)
	var i SpCredential
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.Protocol,
		&i.Status,
		&i.SystemID,
		&i.PasswordHash,
		&i.BindType,
		&i.ApiKeyHash,
		&i.ApiKeyIdentifier,
		&i.HttpConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RoutingGroupID,
	)
	return i, err
}

const createServiceProvider = `-- name: CreateServiceProvider :one
INSERT INTO service_providers (name, email, status, default_currency_code)
VALUES ($1, $2, $3, $4)
RETURNING id, name, email, status, default_currency_code, created_at, updated_at
`

type CreateServiceProviderParams struct {
	Name                string `json:"name"`
	Email               string `json:"email"`
	Status              string `json:"status"`
	DefaultCurrencyCode string `json:"defaultCurrencyCode"`
}

func (q *Queries) CreateServiceProvider(ctx context.Context, arg CreateServiceProviderParams) (ServiceProvider, error) {
	row := q.db.QueryRow(ctx, createServiceProvider,
		arg.Name,
		arg.Email,
		arg.Status,
		arg.DefaultCurrencyCode,
	)
	var i ServiceProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Status,
		&i.DefaultCurrencyCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (service_provider_id, currency_code, balance, low_balance_threshold)
VALUES ($1, $2, $3, $4)
RETURNING id, service_provider_id, currency_code, balance, low_balance_threshold, low_balance_notified_at, created_at, updated_at
`

type CreateWalletParams struct {
	ServiceProviderID   int32           `json:"serviceProviderId"`
	CurrencyCode        string          `json:"currencyCode"`
	Balance             decimal.Decimal `json:"balance"`
	LowBalanceThreshold decimal.Decimal `json:"lowBalanceThreshold"`
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet,
		arg.ServiceProviderID,
		arg.CurrencyCode,
		arg.Balance,
		arg.LowBalanceThreshold,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.CurrencyCode,
		&i.Balance,
		&i.LowBalanceThreshold,
		&i.LowBalanceNotifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteServiceProvider = `-- name: DeleteServiceProvider :exec
DELETE FROM service_providers
WHERE id = $1
`

func (q *Queries) DeleteServiceProvider(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteServiceProvider, id)
	return err
}

const getSPCredentialBySystemID = `-- name: GetSPCredentialBySystemID :one
SELECT
    spc.id,
    spc.service_provider_id,
    spc.protocol,
    spc.status,
    spc.system_id,
    spc.password_hash,
    spc.bind_type,
    spc.http_config,
    spc.created_at,
    spc.updated_at,
    sp.name as service_provider_name,
    sp.default_currency_code -- Include currency
FROM sp_credentials spc -- Use new table name
JOIN service_providers sp ON spc.service_provider_id = sp.id
WHERE spc.protocol = 'smpp' -- Ensure it's an SMPP credential
  AND spc.system_id = $1    -- Expects sql.NullString or string based on sqlc generation
  AND spc.status = 'active'
LIMIT 1
`

type GetSPCredentialBySystemIDRow struct {
	ID                  int32              `json:"id"`
	ServiceProviderID   int32              `json:"serviceProviderId"`
	Protocol            string             `json:"protocol"`
	Status              string             `json:"status"`
	SystemID            *string            `json:"systemId"`
	PasswordHash        *string            `json:"passwordHash"`
	BindType            *string            `json:"bindType"`
	HttpConfig          []byte             `json:"httpConfig"`
	CreatedAt           pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt           pgtype.Timestamptz `json:"updatedAt"`
	ServiceProviderName string             `json:"serviceProviderName"`
	DefaultCurrencyCode string             `json:"defaultCurrencyCode"`
}

func (q *Queries) GetSPCredentialBySystemID(ctx context.Context, systemID *string) (GetSPCredentialBySystemIDRow, error) {
	row := q.db.QueryRow(ctx, getSPCredentialBySystemID, systemID)
	var i GetSPCredentialBySystemIDRow
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.Protocol,
		&i.Status,
		&i.SystemID,
		&i.PasswordHash,
		&i.BindType,
		&i.HttpConfig,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServiceProviderName,
		&i.DefaultCurrencyCode,
	)
	return i, err
}

const getServiceProviderByID = `-- name: GetServiceProviderByID :one
SELECT id, name, email, status, default_currency_code, created_at, updated_at FROM service_providers WHERE id = $1 LIMIT 1
`

func (q *Queries) GetServiceProviderByID(ctx context.Context, id int32) (ServiceProvider, error) {
	row := q.db.QueryRow(ctx, getServiceProviderByID, id)
	var i ServiceProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Status,
		&i.DefaultCurrencyCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listServiceProviders = `-- name: ListServiceProviders :many
SELECT id, name, email, status, default_currency_code, created_at, updated_at FROM service_providers
ORDER BY name -- Or created_at
LIMIT $1 OFFSET $2
`

type ListServiceProvidersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListServiceProviders(ctx context.Context, arg ListServiceProvidersParams) ([]ServiceProvider, error) {
	rows, err := q.db.Query(ctx, listServiceProviders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServiceProvider
	for rows.Next() {
		var i ServiceProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Status,
			&i.DefaultCurrencyCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServiceProvider = `-- name: UpdateServiceProvider :one
UPDATE service_providers
SET
    name = COALESCE($1, name), -- Use COALESCE + sqlc.narg for optional updates
    email = COALESCE($2, email),
    status = COALESCE($3, status),
    default_currency_code = COALESCE($4, default_currency_code),
    updated_at = NOW()
WHERE id = $5
RETURNING id, name, email, status, default_currency_code, created_at, updated_at
`

type UpdateServiceProviderParams struct {
	Name                *string `json:"name"`
	Email               *string `json:"email"`
	Status              *string `json:"status"`
	DefaultCurrencyCode *string `json:"defaultCurrencyCode"`
	ID                  int32   `json:"id"`
}

// New Queries:
func (q *Queries) UpdateServiceProvider(ctx context.Context, arg UpdateServiceProviderParams) (ServiceProvider, error) {
	row := q.db.QueryRow(ctx, updateServiceProvider,
		arg.Name,
		arg.Email,
		arg.Status,
		arg.DefaultCurrencyCode,
		arg.ID,
	)
	var i ServiceProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Status,
		&i.DefaultCurrencyCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
