// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: message_seqments.sql

package database

import (
	"context"
)

const createMessageSegment = `-- name: CreateMessageSegment :one
INSERT INTO message_segments (message_id, segment_seqn, created_at)
VALUES ($1, $2, NOW())
RETURNING id
`

type CreateMessageSegmentParams struct {
	MessageID   int64 `json:"messageId"`
	SegmentSeqn int32 `json:"segmentSeqn"`
}

// Creates initial segment record before sending attempt
func (q *Queries) CreateMessageSegment(ctx context.Context, arg CreateMessageSegmentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMessageSegment, arg.MessageID, arg.SegmentSeqn)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findSegmentByMnoMessageID = `-- name: FindSegmentByMnoMessageID :one
SELECT id as segment_id, message_id, segment_seqn
FROM message_segments
WHERE mno_message_id = $1 -- Expects sql.NullString
LIMIT 1
`

type FindSegmentByMnoMessageIDRow struct {
	SegmentID   int64 `json:"segmentId"`
	MessageID   int64 `json:"messageId"`
	SegmentSeqn int32 `json:"segmentSeqn"`
}

// Finds segment details based on MNO Message ID for DLR processing
func (q *Queries) FindSegmentByMnoMessageID(ctx context.Context, mnoMessageID *string) (FindSegmentByMnoMessageIDRow, error) {
	row := q.db.QueryRow(ctx, findSegmentByMnoMessageID, mnoMessageID)
	var i FindSegmentByMnoMessageIDRow
	err := row.Scan(&i.SegmentID, &i.MessageID, &i.SegmentSeqn)
	return i, err
}

const getSegmentStatusesForMessage = `-- name: GetSegmentStatusesForMessage :many
SELECT segment_seqn, dlr_status -- dlr_status is sql.NullString
FROM message_segments
WHERE message_id = $1
ORDER BY segment_seqn
`

type GetSegmentStatusesForMessageRow struct {
	SegmentSeqn int32   `json:"segmentSeqn"`
	DlrStatus   *string `json:"dlrStatus"`
}

// Gets all segment statuses for final status aggregation
func (q *Queries) GetSegmentStatusesForMessage(ctx context.Context, messageID int64) ([]GetSegmentStatusesForMessageRow, error) {
	rows, err := q.db.Query(ctx, getSegmentStatusesForMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSegmentStatusesForMessageRow
	for rows.Next() {
		var i GetSegmentStatusesForMessageRow
		if err := rows.Scan(&i.SegmentSeqn, &i.DlrStatus); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSegmentDLR = `-- name: UpdateSegmentDLR :exec
UPDATE message_segments
SET
    dlr_status = $1,
    dlr_received_at = NOW(),
    error_code = $2       -- (Error code from DLR)
    -- Keep segment-level error_description from MNO? Or clear it? Let's clear.
    -- error_description = NULL
WHERE id = $3
`

type UpdateSegmentDLRParams struct {
	DlrStatus *string `json:"dlrStatus"`
	ErrorCode *string `json:"errorCode"`
	ID        int64   `json:"id"`
}

// Updates segment status based on received DLR
func (q *Queries) UpdateSegmentDLR(ctx context.Context, arg UpdateSegmentDLRParams) error {
	_, err := q.db.Exec(ctx, updateSegmentDLR, arg.DlrStatus, arg.ErrorCode, arg.ID)
	return err
}

const updateSegmentSendFailed = `-- name: UpdateSegmentSendFailed :exec
UPDATE message_segments
SET
    error_code = $1,
    error_description = $2,
    sent_to_mno_at = NOW()  -- Mark attempt time even on failure
WHERE id = $3
`

type UpdateSegmentSendFailedParams struct {
	ErrorCode        *string `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

// Updates segment if MNO submission attempt failed
func (q *Queries) UpdateSegmentSendFailed(ctx context.Context, arg UpdateSegmentSendFailedParams) error {
	_, err := q.db.Exec(ctx, updateSegmentSendFailed, arg.ErrorCode, arg.ErrorDescription, arg.ID)
	return err
}

const updateSegmentSent = `-- name: UpdateSegmentSent :exec
UPDATE message_segments
SET
    mno_message_id = $1,    -- sql.NullString
    mno_connection_id = $2, -- sql.NullInt32
    sent_to_mno_at = NOW(),
    error_code = NULL,      -- Clear previous errors if any
    error_description = NULL
WHERE id = $3
`

type UpdateSegmentSentParams struct {
	MnoMessageID    *string `json:"mnoMessageId"`
	MnoConnectionID *int32  `json:"mnoConnectionId"`
	ID              int64   `json:"id"`
}

// Updates segment after successful MNO submission
func (q *Queries) UpdateSegmentSent(ctx context.Context, arg UpdateSegmentSentParams) error {
	_, err := q.db.Exec(ctx, updateSegmentSent, arg.MnoMessageID, arg.MnoConnectionID, arg.ID)
	return err
}
