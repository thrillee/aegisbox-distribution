// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: message.sql

package database

import (
	"context"
)

const findMessageByMnoMessageID = `-- name: FindMessageByMnoMessageID :one
SELECT id, service_provider_id, routed_mno_id
FROM messages
WHERE id IN (
    SELECT message_id FROM message_segments
    WHERE mno_message_id = $1
)
AND sent_to_mno_at > NOW() - INTERVAL '7 days'
LIMIT 1
`

type FindMessageByMnoMessageIDRow struct {
	ID                int64  `json:"id"`
	ServiceProviderID int32  `json:"serviceProviderId"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
}

func (q *Queries) FindMessageByMnoMessageID(ctx context.Context, mnoMessageID *string) (FindMessageByMnoMessageIDRow, error) {
	row := q.db.QueryRow(ctx, findMessageByMnoMessageID, mnoMessageID)
	var i FindMessageByMnoMessageIDRow
	err := row.Scan(&i.ID, &i.ServiceProviderID, &i.RoutedMnoID)
	return i, err
}

const getMessageDetailsForPricing = `-- name: GetMessageDetailsForPricing :one
SELECT service_provider_id, routed_mno_id, currency_code, total_segments
FROM messages
WHERE id = $1
LIMIT 1
`

type GetMessageDetailsForPricingRow struct {
	ServiceProviderID int32   `json:"serviceProviderId"`
	RoutedMnoID       *int32  `json:"routedMnoId"`
	CurrencyCode      *string `json:"currencyCode"`
	TotalSegments     int32   `json:"totalSegments"`
}

func (q *Queries) GetMessageDetailsForPricing(ctx context.Context, id int64) (GetMessageDetailsForPricingRow, error) {
	row := q.db.QueryRow(ctx, getMessageDetailsForPricing, id)
	var i GetMessageDetailsForPricingRow
	err := row.Scan(
		&i.ServiceProviderID,
		&i.RoutedMnoID,
		&i.CurrencyCode,
		&i.TotalSegments,
	)
	return i, err
}

const getMessageDetailsForSending = `-- name: GetMessageDetailsForSending :one
SELECT id, destination_msisdn, short_message, approved_sender_id, routed_mno_id, sender_id_used
FROM messages
WHERE id = $1
`

type GetMessageDetailsForSendingRow struct {
	ID                int64  `json:"id"`
	DestinationMsisdn string `json:"destinationMsisdn"`
	ShortMessage      string `json:"shortMessage"`
	ApprovedSenderID  *int32 `json:"approvedSenderId"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
	SenderIDUsed      string `json:"senderIdUsed"`
}

func (q *Queries) GetMessageDetailsForSending(ctx context.Context, id int64) (GetMessageDetailsForSendingRow, error) {
	row := q.db.QueryRow(ctx, getMessageDetailsForSending, id)
	var i GetMessageDetailsForSendingRow
	err := row.Scan(
		&i.ID,
		&i.DestinationMsisdn,
		&i.ShortMessage,
		&i.ApprovedSenderID,
		&i.RoutedMnoID,
		&i.SenderIDUsed,
	)
	return i, err
}

const getMessagesByStatus = `-- name: GetMessagesByStatus :many
SELECT id, service_provider_id, destination_msisdn, sender_id_used, routed_mno_id
FROM messages
WHERE processing_status = $1
ORDER BY received_at
LIMIT $2
FOR UPDATE SKIP LOCKED
`

type GetMessagesByStatusParams struct {
	ProcessingStatus string `json:"processingStatus"`
	Limit            int32  `json:"limit"`
}

type GetMessagesByStatusRow struct {
	ID                int64  `json:"id"`
	ServiceProviderID int32  `json:"serviceProviderId"`
	DestinationMsisdn string `json:"destinationMsisdn"`
	SenderIDUsed      string `json:"senderIdUsed"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
}

func (q *Queries) GetMessagesByStatus(ctx context.Context, arg GetMessagesByStatusParams) ([]GetMessagesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getMessagesByStatus, arg.ProcessingStatus, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesByStatusRow
	for rows.Next() {
		var i GetMessagesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ServiceProviderID,
			&i.DestinationMsisdn,
			&i.SenderIDUsed,
			&i.RoutedMnoID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesToPrice = `-- name: GetMessagesToPrice :many
SELECT id, service_provider_id, routed_mno_id
FROM messages
WHERE processing_status = 'routed'
ORDER BY received_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type GetMessagesToPriceRow struct {
	ID                int64  `json:"id"`
	ServiceProviderID int32  `json:"serviceProviderId"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
}

func (q *Queries) GetMessagesToPrice(ctx context.Context, limit int32) ([]GetMessagesToPriceRow, error) {
	rows, err := q.db.Query(ctx, getMessagesToPrice, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesToPriceRow
	for rows.Next() {
		var i GetMessagesToPriceRow
		if err := rows.Scan(&i.ID, &i.ServiceProviderID, &i.RoutedMnoID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesToRoute = `-- name: GetMessagesToRoute :many
SELECT id, destination_msisdn, service_provider_id, sender_id_used
FROM messages
WHERE processing_status = 'received'
ORDER BY received_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type GetMessagesToRouteRow struct {
	ID                int64  `json:"id"`
	DestinationMsisdn string `json:"destinationMsisdn"`
	ServiceProviderID int32  `json:"serviceProviderId"`
	SenderIDUsed      string `json:"senderIdUsed"`
}

func (q *Queries) GetMessagesToRoute(ctx context.Context, limit int32) ([]GetMessagesToRouteRow, error) {
	rows, err := q.db.Query(ctx, getMessagesToRoute, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesToRouteRow
	for rows.Next() {
		var i GetMessagesToRouteRow
		if err := rows.Scan(
			&i.ID,
			&i.DestinationMsisdn,
			&i.ServiceProviderID,
			&i.SenderIDUsed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesToSend = `-- name: GetMessagesToSend :many
SELECT id, destination_msisdn, short_message, sender_id_used, routed_mno_id, approved_sender_id, template_id
FROM messages
WHERE processing_status = 'queued_for_send'
ORDER BY processed_for_queue_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type GetMessagesToSendRow struct {
	ID                int64  `json:"id"`
	DestinationMsisdn string `json:"destinationMsisdn"`
	ShortMessage      string `json:"shortMessage"`
	SenderIDUsed      string `json:"senderIdUsed"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
	ApprovedSenderID  *int32 `json:"approvedSenderId"`
	TemplateID        *int32 `json:"templateId"`
}

func (q *Queries) GetMessagesToSend(ctx context.Context, limit int32) ([]GetMessagesToSendRow, error) {
	rows, err := q.db.Query(ctx, getMessagesToSend, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesToSendRow
	for rows.Next() {
		var i GetMessagesToSendRow
		if err := rows.Scan(
			&i.ID,
			&i.DestinationMsisdn,
			&i.ShortMessage,
			&i.SenderIDUsed,
			&i.RoutedMnoID,
			&i.ApprovedSenderID,
			&i.TemplateID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMessageIn = `-- name: InsertMessageIn :one
INSERT INTO messages (
    service_provider_id, smpp_credential_id, client_message_id, sender_id_used,
    destination_msisdn, short_message, processing_status, final_status,
    received_at
) VALUES (
    $1, $2, $3, $4, $5, $6, 'received', 'pending', NOW()
) RETURNING id
`

type InsertMessageInParams struct {
	ServiceProviderID int32   `json:"serviceProviderId"`
	SmppCredentialID  int32   `json:"smppCredentialId"`
	ClientMessageID   *string `json:"clientMessageId"`
	SenderIDUsed      string  `json:"senderIdUsed"`
	DestinationMsisdn string  `json:"destinationMsisdn"`
	ShortMessage      string  `json:"shortMessage"`
}

func (q *Queries) InsertMessageIn(ctx context.Context, arg InsertMessageInParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertMessageIn,
		arg.ServiceProviderID,
		arg.SmppCredentialID,
		arg.ClientMessageID,
		arg.SenderIDUsed,
		arg.DestinationMsisdn,
		arg.ShortMessage,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const markMessageSendFailed = `-- name: MarkMessageSendFailed :exec
UPDATE messages
SET processing_status = 'failed_queueing',
    send_status = 'send_failed',
    final_status = 'failed',
    error_code = $1,
    error_description = $2,
    completed_at = NOW()
WHERE id = $3
`

type MarkMessageSendFailedParams struct {
	ErrorCode        *int32  `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

func (q *Queries) MarkMessageSendFailed(ctx context.Context, arg MarkMessageSendFailedParams) error {
	_, err := q.db.Exec(ctx, markMessageSendFailed, arg.ErrorCode, arg.ErrorDescription, arg.ID)
	return err
}

const markMessageSent = `-- name: MarkMessageSent :exec
UPDATE messages
SET processing_status = 'sent',
    send_status = 'sent',
    completed_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkMessageSent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markMessageSent, id)
	return err
}

const updateMessageDLRStatus = `-- name: UpdateMessageDLRStatus :exec
UPDATE message_segments
SET dlr_status = $1,
    dlr_received_at = NOW(),
    error_code = $2,
    error_description = $3
WHERE mno_message_id = $4
`

type UpdateMessageDLRStatusParams struct {
	DlrStatus        *string `json:"dlrStatus"`
	ErrorCode        *int32  `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	MnoMessageID     *string `json:"mnoMessageId"`
}

func (q *Queries) UpdateMessageDLRStatus(ctx context.Context, arg UpdateMessageDLRStatusParams) error {
	_, err := q.db.Exec(ctx, updateMessageDLRStatus,
		arg.DlrStatus,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.MnoMessageID,
	)
	return err
}

const updateMessagePriced = `-- name: UpdateMessagePriced :exec
UPDATE messages
SET processing_status = $1,
    error_code = $2,
    error_description = $3,
    processed_for_queue_at = CASE WHEN $1 = 'queued_for_send' THEN NOW() ELSE processed_for_queue_at END
WHERE id = $4
`

type UpdateMessagePricedParams struct {
	ProcessingStatus string  `json:"processingStatus"`
	ErrorCode        *int32  `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

func (q *Queries) UpdateMessagePriced(ctx context.Context, arg UpdateMessagePricedParams) error {
	_, err := q.db.Exec(ctx, updateMessagePriced,
		arg.ProcessingStatus,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.ID,
	)
	return err
}

const updateMessageRoutingInfo = `-- name: UpdateMessageRoutingInfo :exec
UPDATE messages
SET processing_status = $1,
    routed_mno_id = $2,
    error_code = $3,
    error_description = $4
WHERE id = $5
`

type UpdateMessageRoutingInfoParams struct {
	ProcessingStatus string  `json:"processingStatus"`
	RoutedMnoID      *int32  `json:"routedMnoId"`
	ErrorCode        *int32  `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

func (q *Queries) UpdateMessageRoutingInfo(ctx context.Context, arg UpdateMessageRoutingInfoParams) error {
	_, err := q.db.Exec(ctx, updateMessageRoutingInfo,
		arg.ProcessingStatus,
		arg.RoutedMnoID,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.ID,
	)
	return err
}

const updateMessageValidatedRouted = `-- name: UpdateMessageValidatedRouted :exec
UPDATE messages
SET processing_status = $1,
    routed_mno_id = $2,
    approved_sender_id = $3,
    template_id = $4,
    error_code = $5,
    error_description = $6
WHERE id = $7
`

type UpdateMessageValidatedRoutedParams struct {
	ProcessingStatus string  `json:"processingStatus"`
	RoutedMnoID      *int32  `json:"routedMnoId"`
	ApprovedSenderID *int32  `json:"approvedSenderId"`
	TemplateID       *int32  `json:"templateId"`
	ErrorCode        *int32  `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

func (q *Queries) UpdateMessageValidatedRouted(ctx context.Context, arg UpdateMessageValidatedRoutedParams) error {
	_, err := q.db.Exec(ctx, updateMessageValidatedRouted,
		arg.ProcessingStatus,
		arg.RoutedMnoID,
		arg.ApprovedSenderID,
		arg.TemplateID,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.ID,
	)
	return err
}
