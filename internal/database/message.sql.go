// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: message.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countMessageDetails = `-- name: CountMessageDetails :one
SELECT count(DISTINCT m.id)
FROM messages m
JOIN service_providers sp ON m.service_provider_id = sp.id
JOIN sp_credentials spc ON m.sp_credential_id = spc.id
LEFT JOIN mnos mn ON m.routed_mno_id = mn.id
LEFT JOIN message_segments ms_filter ON m.id = ms_filter.message_id AND $1::TEXT IS NOT NULL
WHERE
  ($2::INT IS NULL OR m.service_provider_id = $2)
  AND ($3::INT IS NULL OR m.sp_credential_id = $3)
  AND ($4::INT IS NULL OR m.routed_mno_id = $4)
  AND ($5::TEXT IS NULL OR m.original_source_addr = $5)
  AND ($6::TEXT IS NULL OR m.original_destination_addr = $6)
  AND ($7::TEXT IS NULL OR m.final_status = $7)
  AND ($8::TEXT IS NULL OR m.client_message_id = $8)
  AND ($9::TEXT IS NULL OR m.client_ref = $9)
  -- Subquery EXISTS check for mno_message_id filter to avoid inflating count due to join
  AND ($1::TEXT IS NULL OR EXISTS (
        SELECT 1 FROM message_segments ms_exists
        WHERE ms_exists.message_id = m.id AND ms_exists.mno_message_id = $1
  ))
  AND ($10::TIMESTAMPTZ IS NULL OR m.submitted_at >= $10)
  AND ($11::TIMESTAMPTZ IS NULL OR m.submitted_at < $11::TIMESTAMPTZ + INTERVAL '1 day')
`

type CountMessageDetailsParams struct {
	MnoMessageID    *string            `json:"mnoMessageId"`
	SpID            *int32             `json:"spId"`
	SpCredentialID  *int32             `json:"spCredentialId"`
	MnoID           *int32             `json:"mnoId"`
	SenderID        *string            `json:"senderId"`
	Destination     *string            `json:"destination"`
	FinalStatus     *string            `json:"finalStatus"`
	ClientMessageID *string            `json:"clientMessageId"`
	ClientRef       *string            `json:"clientRef"`
	StartDate       pgtype.Timestamptz `json:"startDate"`
	EndDate         pgtype.Timestamptz `json:"endDate"`
}

// Counts messages based on optional filters, joining necessary tables.
// Only JOIN segments if filtering by mno_message_id
func (q *Queries) CountMessageDetails(ctx context.Context, arg CountMessageDetailsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMessageDetails,
		arg.MnoMessageID,
		arg.SpID,
		arg.SpCredentialID,
		arg.MnoID,
		arg.SenderID,
		arg.Destination,
		arg.FinalStatus,
		arg.ClientMessageID,
		arg.ClientRef,
		arg.StartDate,
		arg.EndDate,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findMessageByMnoMessageID = `-- name: FindMessageByMnoMessageID :one
SELECT id, service_provider_id, routed_mno_id
FROM messages
WHERE id IN (
    SELECT message_id FROM message_segments
    WHERE mno_message_id = $1
)
AND sent_to_mno_at > NOW() - INTERVAL '7 days'
LIMIT 1
`

type FindMessageByMnoMessageIDRow struct {
	ID                int64  `json:"id"`
	ServiceProviderID int32  `json:"serviceProviderId"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
}

func (q *Queries) FindMessageByMnoMessageID(ctx context.Context, mnoMessageID *string) (FindMessageByMnoMessageIDRow, error) {
	row := q.db.QueryRow(ctx, findMessageByMnoMessageID, mnoMessageID)
	var i FindMessageByMnoMessageIDRow
	err := row.Scan(&i.ID, &i.ServiceProviderID, &i.RoutedMnoID)
	return i, err
}

const getMessageDetailsForPricing = `-- name: GetMessageDetailsForPricing :one
SELECT
    id,
    service_provider_id,
    routed_mno_id,
    currency_code,
    total_segments
FROM messages
WHERE id = $1
LIMIT 1
`

type GetMessageDetailsForPricingRow struct {
	ID                int64  `json:"id"`
	ServiceProviderID int32  `json:"serviceProviderId"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
	CurrencyCode      string `json:"currencyCode"`
	TotalSegments     int32  `json:"totalSegments"`
}

// Select fields needed by the Pricer
func (q *Queries) GetMessageDetailsForPricing(ctx context.Context, id int64) (GetMessageDetailsForPricingRow, error) {
	row := q.db.QueryRow(ctx, getMessageDetailsForPricing, id)
	var i GetMessageDetailsForPricingRow
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.RoutedMnoID,
		&i.CurrencyCode,
		&i.TotalSegments,
	)
	return i, err
}

const getMessageDetailsForSending = `-- name: GetMessageDetailsForSending :one
SELECT
    id,
    service_provider_id,
    original_source_addr, -- Used as SenderID for MNO
    original_destination_addr,
    short_message,        -- Full content
    total_segments,
    currency_code,
    client_ref,
    submitted_at,
    -- Also select fields needed for DataCoding, ESMClass, RequestDLR etc. if stored
    -- data_coding, esm_class, request_dlr, is_flash
    routed_mno_id         -- Needed by Processor to select MNO Connector
FROM messages
WHERE id = $1
LIMIT 1
`

type GetMessageDetailsForSendingRow struct {
	ID                      int64              `json:"id"`
	ServiceProviderID       int32              `json:"serviceProviderId"`
	OriginalSourceAddr      string             `json:"originalSourceAddr"`
	OriginalDestinationAddr string             `json:"originalDestinationAddr"`
	ShortMessage            string             `json:"shortMessage"`
	TotalSegments           int32              `json:"totalSegments"`
	CurrencyCode            string             `json:"currencyCode"`
	ClientRef               *string            `json:"clientRef"`
	SubmittedAt             pgtype.Timestamptz `json:"submittedAt"`
	RoutedMnoID             *int32             `json:"routedMnoId"`
}

func (q *Queries) GetMessageDetailsForSending(ctx context.Context, id int64) (GetMessageDetailsForSendingRow, error) {
	row := q.db.QueryRow(ctx, getMessageDetailsForSending, id)
	var i GetMessageDetailsForSendingRow
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.OriginalSourceAddr,
		&i.OriginalDestinationAddr,
		&i.ShortMessage,
		&i.TotalSegments,
		&i.CurrencyCode,
		&i.ClientRef,
		&i.SubmittedAt,
		&i.RoutedMnoID,
	)
	return i, err
}

const getMessageFinalStatus = `-- name: GetMessageFinalStatus :one
SELECT final_status FROM messages WHERE id = $1
`

func (q *Queries) GetMessageFinalStatus(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getMessageFinalStatus, id)
	var final_status string
	err := row.Scan(&final_status)
	return final_status, err
}

const getMessageTotalSegments = `-- name: GetMessageTotalSegments :one
SELECT total_segments FROM messages WHERE id = $1
`

func (q *Queries) GetMessageTotalSegments(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, getMessageTotalSegments, id)
	var total_segments int32
	err := row.Scan(&total_segments)
	return total_segments, err
}

const getMessagesByStatus = `-- name: GetMessagesByStatus :many
SELECT id, service_provider_id, sp_credential_id, original_destination_addr, original_source_addr 
FROM messages
WHERE processing_status = $1 -- e.g., 'received', 'routed', 'queued_for_send'
ORDER BY received_at -- Process in FIFO order
LIMIT $2
FOR UPDATE SKIP LOCKED
`

type GetMessagesByStatusParams struct {
	ProcessingStatus string `json:"processingStatus"`
	Limit            int32  `json:"limit"`
}

type GetMessagesByStatusRow struct {
	ID                      int64  `json:"id"`
	ServiceProviderID       int32  `json:"serviceProviderId"`
	SpCredentialID          int32  `json:"spCredentialId"`
	OriginalDestinationAddr string `json:"originalDestinationAddr"`
	OriginalSourceAddr      string `json:"originalSourceAddr"`
}

func (q *Queries) GetMessagesByStatus(ctx context.Context, arg GetMessagesByStatusParams) ([]GetMessagesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getMessagesByStatus, arg.ProcessingStatus, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesByStatusRow
	for rows.Next() {
		var i GetMessagesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ServiceProviderID,
			&i.SpCredentialID,
			&i.OriginalDestinationAddr,
			&i.OriginalSourceAddr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesToPrice = `-- name: GetMessagesToPrice :many
SELECT id, service_provider_id, routed_mno_id
FROM messages
WHERE processing_status = 'routed'
ORDER BY received_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type GetMessagesToPriceRow struct {
	ID                int64  `json:"id"`
	ServiceProviderID int32  `json:"serviceProviderId"`
	RoutedMnoID       *int32 `json:"routedMnoId"`
}

func (q *Queries) GetMessagesToPrice(ctx context.Context, limit int32) ([]GetMessagesToPriceRow, error) {
	rows, err := q.db.Query(ctx, getMessagesToPrice, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesToPriceRow
	for rows.Next() {
		var i GetMessagesToPriceRow
		if err := rows.Scan(&i.ID, &i.ServiceProviderID, &i.RoutedMnoID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSPMessageInfoForDLR = `-- name: GetSPMessageInfoForDLR :one

SELECT
    m.id,
    m.service_provider_id,
    m.client_ref,
    m.client_message_id,
    m.original_source_addr,
    m.original_destination_addr,
    m.submitted_at,
    m.completed_at, -- May not be set when DLR arrives
    m.total_segments,
    spc.protocol,
    spc.system_id,    -- This column is nullable
    spc.http_config   -- This is JSONB (likely []byte or custom type in Go)
FROM messages m
JOIN sp_credentials spc ON m.sp_credential_id = spc.id -- Use correct table name
WHERE m.id = $1
LIMIT 1
`

type GetSPMessageInfoForDLRRow struct {
	ID                      int64              `json:"id"`
	ServiceProviderID       int32              `json:"serviceProviderId"`
	ClientRef               *string            `json:"clientRef"`
	ClientMessageID         *string            `json:"clientMessageId"`
	OriginalSourceAddr      string             `json:"originalSourceAddr"`
	OriginalDestinationAddr string             `json:"originalDestinationAddr"`
	SubmittedAt             pgtype.Timestamptz `json:"submittedAt"`
	CompletedAt             pgtype.Timestamptz `json:"completedAt"`
	TotalSegments           int32              `json:"totalSegments"`
	Protocol                string             `json:"protocol"`
	SystemID                *string            `json:"systemId"`
	HttpConfig              []byte             `json:"httpConfig"`
}

// Optional: Prevent redundant updates
// Select fields needed for DLR forwarding
func (q *Queries) GetSPMessageInfoForDLR(ctx context.Context, id int64) (GetSPMessageInfoForDLRRow, error) {
	row := q.db.QueryRow(ctx, getSPMessageInfoForDLR, id)
	var i GetSPMessageInfoForDLRRow
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.ClientRef,
		&i.ClientMessageID,
		&i.OriginalSourceAddr,
		&i.OriginalDestinationAddr,
		&i.SubmittedAt,
		&i.CompletedAt,
		&i.TotalSegments,
		&i.Protocol,
		&i.SystemID,
		&i.HttpConfig,
	)
	return i, err
}

const insertMessageIn = `-- name: InsertMessageIn :one
INSERT INTO messages (
    service_provider_id,
    sp_credential_id, -- Use new table name FK
    client_message_id,
    client_ref,
    original_source_addr,
    original_destination_addr,
    short_message,
    total_segments,
    currency_code,
    submitted_at,
    routed_mno_id,
    processing_status, -- Initial status
    received_at,
    final_status       -- Initial status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), 'pending'
) RETURNING id
`

type InsertMessageInParams struct {
	ServiceProviderID       int32              `json:"serviceProviderId"`
	SpCredentialID          int32              `json:"spCredentialId"`
	ClientMessageID         *string            `json:"clientMessageId"`
	ClientRef               *string            `json:"clientRef"`
	OriginalSourceAddr      string             `json:"originalSourceAddr"`
	OriginalDestinationAddr string             `json:"originalDestinationAddr"`
	ShortMessage            string             `json:"shortMessage"`
	TotalSegments           int32              `json:"totalSegments"`
	CurrencyCode            string             `json:"currencyCode"`
	SubmittedAt             pgtype.Timestamptz `json:"submittedAt"`
	RoutedMnoID             *int32             `json:"routedMnoId"`
	ProcessingStatus        string             `json:"processingStatus"`
}

func (q *Queries) InsertMessageIn(ctx context.Context, arg InsertMessageInParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertMessageIn,
		arg.ServiceProviderID,
		arg.SpCredentialID,
		arg.ClientMessageID,
		arg.ClientRef,
		arg.OriginalSourceAddr,
		arg.OriginalDestinationAddr,
		arg.ShortMessage,
		arg.TotalSegments,
		arg.CurrencyCode,
		arg.SubmittedAt,
		arg.RoutedMnoID,
		arg.ProcessingStatus,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listMessageDetails = `-- name: ListMessageDetails :many
SELECT DISTINCT ON (m.id) -- Ensures one row per message ID even with segment join
    m.id,
    m.service_provider_id,
    sp.name as service_provider_name, -- Joined SP Name
    m.sp_credential_id,
    COALESCE(spc.system_id, spc.api_key_identifier) AS credential_identifier, -- Joined Credential Identifier
    spc.protocol, -- Joined Protocol
    m.client_message_id,
    m.client_ref,
    m.original_source_addr,
    m.original_destination_addr,
    m.total_segments,
    m.submitted_at,
    m.received_at,
    m.routed_mno_id,
    mn.name as mno_name, -- Joined MNO Name
    m.currency_code,
    m.cost,
    m.processing_status,
    m.final_status,
    m.error_code,
    m.error_description,
    m.completed_at,
    -- Aggregate MNO Message IDs from segments for display (can be NULL if no segments sent/recorded)
    (SELECT string_agg(ms.mno_message_id, ', ') FROM message_segments ms WHERE ms.message_id = m.id) AS mno_message_ids
FROM messages m
JOIN service_providers sp ON m.service_provider_id = sp.id
JOIN sp_credentials spc ON m.sp_credential_id = spc.id
LEFT JOIN mnos mn ON m.routed_mno_id = mn.id
LEFT JOIN message_segments ms_filter ON m.id = ms_filter.message_id AND $1::TEXT IS NOT NULL
WHERE
  ($2::INT IS NULL OR m.service_provider_id = $2)                     -- $1
  AND ($3::INT IS NULL OR m.sp_credential_id = $3) -- $2
  AND ($4::INT IS NULL OR m.routed_mno_id = $4)                     -- $3
  AND ($5::TEXT IS NULL OR m.original_source_addr = $5)       -- $4
  AND ($6::TEXT IS NULL OR m.original_destination_addr = $6) -- $5
  AND ($7::TEXT IS NULL OR m.final_status = $7)         -- $6
  AND ($8::TEXT IS NULL OR m.client_message_id = $8) -- $7
  AND ($9::TEXT IS NULL OR m.client_ref = $9)             -- $8
  AND ($1::TEXT IS NULL OR EXISTS (                                       -- $9 (mno_message_id filter)
        SELECT 1 FROM message_segments ms_exists
        WHERE ms_exists.message_id = m.id AND ms_exists.mno_message_id = $1
  ))
  AND ($10::TIMESTAMPTZ IS NULL OR m.submitted_at >= $10)        -- $10
  AND ($11::TIMESTAMPTZ IS NULL OR m.submitted_at < $11::TIMESTAMPTZ + INTERVAL '1 day') -- $11 (end_date filter)
ORDER BY
    m.id DESC -- Order must match DISTINCT ON column first for predictable results
    -- m.submitted_at DESC -- Cannot easily use submitted_at with DISTINCT ON (m.id) unless included
LIMIT $13::INT OFFSET $12::INT
`

type ListMessageDetailsParams struct {
	MnoMessageID    *string            `json:"mnoMessageId"`
	SpID            *int32             `json:"spId"`
	SpCredentialID  *int32             `json:"spCredentialId"`
	MnoID           *int32             `json:"mnoId"`
	SenderID        *string            `json:"senderId"`
	Destination     *string            `json:"destination"`
	FinalStatus     *string            `json:"finalStatus"`
	ClientMessageID *string            `json:"clientMessageId"`
	ClientRef       *string            `json:"clientRef"`
	StartDate       pgtype.Timestamptz `json:"startDate"`
	EndDate         pgtype.Timestamptz `json:"endDate"`
	QueryOffset     int32              `json:"queryOffset"`
	QueryLimit      int32              `json:"queryLimit"`
}

type ListMessageDetailsRow struct {
	ID                      int64              `json:"id"`
	ServiceProviderID       int32              `json:"serviceProviderId"`
	ServiceProviderName     string             `json:"serviceProviderName"`
	SpCredentialID          int32              `json:"spCredentialId"`
	CredentialIdentifier    *string            `json:"credentialIdentifier"`
	Protocol                string             `json:"protocol"`
	ClientMessageID         *string            `json:"clientMessageId"`
	ClientRef               *string            `json:"clientRef"`
	OriginalSourceAddr      string             `json:"originalSourceAddr"`
	OriginalDestinationAddr string             `json:"originalDestinationAddr"`
	TotalSegments           int32              `json:"totalSegments"`
	SubmittedAt             pgtype.Timestamptz `json:"submittedAt"`
	ReceivedAt              pgtype.Timestamptz `json:"receivedAt"`
	RoutedMnoID             *int32             `json:"routedMnoId"`
	MnoName                 *string            `json:"mnoName"`
	CurrencyCode            string             `json:"currencyCode"`
	Cost                    pgtype.Numeric     `json:"cost"`
	ProcessingStatus        string             `json:"processingStatus"`
	FinalStatus             string             `json:"finalStatus"`
	ErrorCode               *string            `json:"errorCode"`
	ErrorDescription        *string            `json:"errorDescription"`
	CompletedAt             pgtype.Timestamptz `json:"completedAt"`
	MnoMessageIds           []byte             `json:"mnoMessageIds"`
}

// Lists detailed message information based on optional filters with pagination. Excludes message content.
// LEFT JOIN needed for EXISTS filter below, but DISTINCT ON handles duplicates if join remains
func (q *Queries) ListMessageDetails(ctx context.Context, arg ListMessageDetailsParams) ([]ListMessageDetailsRow, error) {
	rows, err := q.db.Query(ctx, listMessageDetails,
		arg.MnoMessageID,
		arg.SpID,
		arg.SpCredentialID,
		arg.MnoID,
		arg.SenderID,
		arg.Destination,
		arg.FinalStatus,
		arg.ClientMessageID,
		arg.ClientRef,
		arg.StartDate,
		arg.EndDate,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessageDetailsRow
	for rows.Next() {
		var i ListMessageDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ServiceProviderID,
			&i.ServiceProviderName,
			&i.SpCredentialID,
			&i.CredentialIdentifier,
			&i.Protocol,
			&i.ClientMessageID,
			&i.ClientRef,
			&i.OriginalSourceAddr,
			&i.OriginalDestinationAddr,
			&i.TotalSegments,
			&i.SubmittedAt,
			&i.ReceivedAt,
			&i.RoutedMnoID,
			&i.MnoName,
			&i.CurrencyCode,
			&i.Cost,
			&i.ProcessingStatus,
			&i.FinalStatus,
			&i.ErrorCode,
			&i.ErrorDescription,
			&i.CompletedAt,
			&i.MnoMessageIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageSendFailed = `-- name: MarkMessageSendFailed :exec
UPDATE messages
SET
    processing_status = 'send_failed', -- Or keep 'send_attempted' and set final_status?
    final_status = 'failed',
    error_code = $1,
    error_description = $2,
    completed_at = NOW()
WHERE id = $3
`

type MarkMessageSendFailedParams struct {
	ErrorCode        *string `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

// Use this if the Sender.Send fails catastrophically *before* MNO gets involved,
// or potentially as the final aggregated status if needed.
func (q *Queries) MarkMessageSendFailed(ctx context.Context, arg MarkMessageSendFailedParams) error {
	_, err := q.db.Exec(ctx, markMessageSendFailed, arg.ErrorCode, arg.ErrorDescription, arg.ID)
	return err
}

const markMessageSent = `-- name: MarkMessageSent :exec
UPDATE messages
SET processing_status = 'sent',
    send_status = 'sent',
    completed_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkMessageSent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markMessageSent, id)
	return err
}

const updateMessageDLRStatus = `-- name: UpdateMessageDLRStatus :exec
UPDATE message_segments
SET dlr_status = $1,
    dlr_received_at = NOW(),
    error_code = $2,
    error_description = $3
WHERE mno_message_id = $4
`

type UpdateMessageDLRStatusParams struct {
	DlrStatus        *string `json:"dlrStatus"`
	ErrorCode        *string `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	MnoMessageID     *string `json:"mnoMessageId"`
}

func (q *Queries) UpdateMessageDLRStatus(ctx context.Context, arg UpdateMessageDLRStatusParams) error {
	_, err := q.db.Exec(ctx, updateMessageDLRStatus,
		arg.DlrStatus,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.MnoMessageID,
	)
	return err
}

const updateMessageFinalStatus = `-- name: UpdateMessageFinalStatus :exec
UPDATE messages
SET
    final_status = $1, -- 'delivered', 'failed', 'expired', 'rejected'
    error_code = $2,   -- (Aggregated/final error code)
    error_description = $3, -- (Aggregated/final error description)
    completed_at = NOW()
WHERE id = $4
  AND final_status != $1
`

type UpdateMessageFinalStatusParams struct {
	FinalStatus      string  `json:"finalStatus"`
	ErrorCode        *string `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

// Updates the final aggregated status and error info
func (q *Queries) UpdateMessageFinalStatus(ctx context.Context, arg UpdateMessageFinalStatusParams) error {
	_, err := q.db.Exec(ctx, updateMessageFinalStatus,
		arg.FinalStatus,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.ID,
	)
	return err
}

const updateMessagePriced = `-- name: UpdateMessagePriced :exec
UPDATE messages
SET
    processing_status = $1, -- 'queued_for_send' or 'failed_pricing'
    cost=$2::numeric, -- $2 is decimal.Decimal
    error_code = $3,    
    error_description = $4, 
    processed_for_queue_at = CASE WHEN $5 = 'queued_for_send' THEN NOW() ELSE processed_for_queue_at END
WHERE id = $6
`

type UpdateMessagePricedParams struct {
	ProcessingStatus string          `json:"processingStatus"`
	Column2          decimal.Decimal `json:"column2"`
	ErrorCode        *string         `json:"errorCode"`
	ErrorDescription *string         `json:"errorDescription"`
	Column5          interface{}     `json:"column5"`
	ID               int64           `json:"id"`
}

func (q *Queries) UpdateMessagePriced(ctx context.Context, arg UpdateMessagePricedParams) error {
	_, err := q.db.Exec(ctx, updateMessagePriced,
		arg.ProcessingStatus,
		arg.Column2,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.Column5,
		arg.ID,
	)
	return err
}

const updateMessageRoutingInfo = `-- name: UpdateMessageRoutingInfo :exec
UPDATE messages
SET processing_status = $1,
    routed_mno_id = $2,
    error_code = $3,
    error_description = $4
WHERE id = $5
`

type UpdateMessageRoutingInfoParams struct {
	ProcessingStatus string  `json:"processingStatus"`
	RoutedMnoID      *int32  `json:"routedMnoId"`
	ErrorCode        *string `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

func (q *Queries) UpdateMessageRoutingInfo(ctx context.Context, arg UpdateMessageRoutingInfoParams) error {
	_, err := q.db.Exec(ctx, updateMessageRoutingInfo,
		arg.ProcessingStatus,
		arg.RoutedMnoID,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.ID,
	)
	return err
}

const updateMessageSendAttempted = `-- name: UpdateMessageSendAttempted :exec
UPDATE messages
SET
    processing_status = 'send_attempted'
    -- Optionally clear error code/description if previous failure was transient?
WHERE id = $1
`

// Updates status after Sender.Send finishes (regardless of segment success/failure)
func (q *Queries) UpdateMessageSendAttempted(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateMessageSendAttempted, id)
	return err
}

const updateMessageValidatedRouted = `-- name: UpdateMessageValidatedRouted :exec
UPDATE messages
SET
    processing_status = $1, -- 'routed', 'failed_validation', 'failed_routing'
    routed_mno_id = $2,   
    approved_sender_id = $3,
    template_id = $4,
    error_code = $5,        -- (Mapped internal code)
    error_description = $6 -- (Reason for failure)
WHERE id = $7
`

type UpdateMessageValidatedRoutedParams struct {
	ProcessingStatus string  `json:"processingStatus"`
	RoutedMnoID      *int32  `json:"routedMnoId"`
	ApprovedSenderID *int32  `json:"approvedSenderId"`
	TemplateID       *int32  `json:"templateId"`
	ErrorCode        *string `json:"errorCode"`
	ErrorDescription *string `json:"errorDescription"`
	ID               int64   `json:"id"`
}

func (q *Queries) UpdateMessageValidatedRouted(ctx context.Context, arg UpdateMessageValidatedRoutedParams) error {
	_, err := q.db.Exec(ctx, updateMessageValidatedRouted,
		arg.ProcessingStatus,
		arg.RoutedMnoID,
		arg.ApprovedSenderID,
		arg.TemplateID,
		arg.ErrorCode,
		arg.ErrorDescription,
		arg.ID,
	)
	return err
}
