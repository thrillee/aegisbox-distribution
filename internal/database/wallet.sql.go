// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: wallet.sql

package database

import (
	"context"

	"github.com/shopspring/decimal"
)

const countWalletsBySP = `-- name: CountWalletsBySP :one
SELECT count(*) FROM wallets
WHERE service_provider_id = $1
`

// Counts wallets for a specific Service Provider.
func (q *Queries) CountWalletsBySP(ctx context.Context, serviceProviderID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countWalletsBySP, serviceProviderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWalletTransaction = `-- name: CreateWalletTransaction :one
INSERT INTO wallet_transactions (
    wallet_id, message_id, transaction_type, amount, balance_before, balance_after, description, reference_transaction_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, wallet_id, message_id, transaction_type, amount, balance_before, balance_after, description, transaction_date, reference_transaction_id
`

type CreateWalletTransactionParams struct {
	WalletID               int32           `json:"walletId"`
	MessageID              *int64          `json:"messageId"`
	TransactionType        string          `json:"transactionType"`
	Amount                 decimal.Decimal `json:"amount"`
	BalanceBefore          decimal.Decimal `json:"balanceBefore"`
	BalanceAfter           decimal.Decimal `json:"balanceAfter"`
	Description            *string         `json:"description"`
	ReferenceTransactionID *int64          `json:"referenceTransactionId"`
}

func (q *Queries) CreateWalletTransaction(ctx context.Context, arg CreateWalletTransactionParams) (WalletTransaction, error) {
	row := q.db.QueryRow(ctx, createWalletTransaction,
		arg.WalletID,
		arg.MessageID,
		arg.TransactionType,
		arg.Amount,
		arg.BalanceBefore,
		arg.BalanceAfter,
		arg.Description,
		arg.ReferenceTransactionID,
	)
	var i WalletTransaction
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.MessageID,
		&i.TransactionType,
		&i.Amount,
		&i.BalanceBefore,
		&i.BalanceAfter,
		&i.Description,
		&i.TransactionDate,
		&i.ReferenceTransactionID,
	)
	return i, err
}

const findDebitTransactionForMessage = `-- name: FindDebitTransactionForMessage :one
SELECT id, wallet_id, amount
FROM wallet_transactions
WHERE message_id = $1
  AND transaction_type = 'debit'
LIMIT 1
`

type FindDebitTransactionForMessageRow struct {
	ID       int64           `json:"id"`
	WalletID int32           `json:"walletId"`
	Amount   decimal.Decimal `json:"amount"`
}

func (q *Queries) FindDebitTransactionForMessage(ctx context.Context, messageID *int64) (FindDebitTransactionForMessageRow, error) {
	row := q.db.QueryRow(ctx, findDebitTransactionForMessage, messageID)
	var i FindDebitTransactionForMessageRow
	err := row.Scan(&i.ID, &i.WalletID, &i.Amount)
	return i, err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, service_provider_id, currency_code, balance, low_balance_threshold, low_balance_notified_at, created_at, updated_at FROM wallets WHERE id = $1 LIMIT 1
`

// Gets a specific wallet by its primary ID.
func (q *Queries) GetWalletByID(ctx context.Context, id int32) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.CurrencyCode,
		&i.Balance,
		&i.LowBalanceThreshold,
		&i.LowBalanceNotifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletForUpdate = `-- name: GetWalletForUpdate :one
SELECT id, balance
FROM wallets
WHERE service_provider_id = $1 AND currency_code = $2
FOR UPDATE
`

type GetWalletForUpdateParams struct {
	ServiceProviderID int32  `json:"serviceProviderId"`
	CurrencyCode      string `json:"currencyCode"`
}

type GetWalletForUpdateRow struct {
	ID      int32           `json:"id"`
	Balance decimal.Decimal `json:"balance"`
}

func (q *Queries) GetWalletForUpdate(ctx context.Context, arg GetWalletForUpdateParams) (GetWalletForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getWalletForUpdate, arg.ServiceProviderID, arg.CurrencyCode)
	var i GetWalletForUpdateRow
	err := row.Scan(&i.ID, &i.Balance)
	return i, err
}

const getWalletForUpdateByID = `-- name: GetWalletForUpdateByID :one
SELECT id, service_provider_id, currency_code, balance, low_balance_threshold, low_balance_notified_at, created_at, updated_at
FROM wallets
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetWalletForUpdateByID(ctx context.Context, id int32) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletForUpdateByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.CurrencyCode,
		&i.Balance,
		&i.LowBalanceThreshold,
		&i.LowBalanceNotifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletsBelowThreshold = `-- name: GetWalletsBelowThreshold :many
SELECT w.id as wallet_id, w.balance, w.low_balance_threshold, w.currency_code, sp.id as service_provider_id, sp.email
FROM wallets w
JOIN service_providers sp ON w.service_provider_id = sp.id
WHERE w.balance < w.low_balance_threshold
  AND (w.low_balance_notified_at IS NULL OR w.low_balance_notified_at < NOW() - INTERVAL '24 hours')
`

type GetWalletsBelowThresholdRow struct {
	WalletID            int32           `json:"walletId"`
	Balance             decimal.Decimal `json:"balance"`
	LowBalanceThreshold decimal.Decimal `json:"lowBalanceThreshold"`
	CurrencyCode        string          `json:"currencyCode"`
	ServiceProviderID   int32           `json:"serviceProviderId"`
	Email               string          `json:"email"`
}

func (q *Queries) GetWalletsBelowThreshold(ctx context.Context) ([]GetWalletsBelowThresholdRow, error) {
	rows, err := q.db.Query(ctx, getWalletsBelowThreshold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWalletsBelowThresholdRow
	for rows.Next() {
		var i GetWalletsBelowThresholdRow
		if err := rows.Scan(
			&i.WalletID,
			&i.Balance,
			&i.LowBalanceThreshold,
			&i.CurrencyCode,
			&i.ServiceProviderID,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsBySP = `-- name: ListWalletsBySP :many
SELECT id, service_provider_id, currency_code, balance, low_balance_threshold, low_balance_notified_at, created_at, updated_at FROM wallets
WHERE service_provider_id = $1
ORDER BY currency_code
LIMIT $2 OFFSET $3
`

type ListWalletsBySPParams struct {
	ServiceProviderID int32 `json:"serviceProviderId"`
	Limit             int32 `json:"limit"`
	Offset            int32 `json:"offset"`
}

// Lists wallets for a specific Service Provider, paginated.
func (q *Queries) ListWalletsBySP(ctx context.Context, arg ListWalletsBySPParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsBySP, arg.ServiceProviderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.ServiceProviderID,
			&i.CurrencyCode,
			&i.Balance,
			&i.LowBalanceThreshold,
			&i.LowBalanceNotifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLowBalanceNotifiedAt = `-- name: UpdateLowBalanceNotifiedAt :exec

UPDATE wallets
SET low_balance_notified_at = NOW()
WHERE id = $1
`

// Check threshold and notification time
func (q *Queries) UpdateLowBalanceNotifiedAt(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateLowBalanceNotifiedAt, id)
	return err
}

const updateWalletBalance = `-- name: UpdateWalletBalance :one

UPDATE wallets
SET balance = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, service_provider_id, currency_code, balance, low_balance_threshold, low_balance_notified_at, created_at, updated_at
`

type UpdateWalletBalanceParams struct {
	Balance decimal.Decimal `json:"balance"`
	ID      int32           `json:"id"`
}

// Lock the row for atomic update
func (q *Queries) UpdateWalletBalance(ctx context.Context, arg UpdateWalletBalanceParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, updateWalletBalance, arg.Balance, arg.ID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.ServiceProviderID,
		&i.CurrencyCode,
		&i.Balance,
		&i.LowBalanceThreshold,
		&i.LowBalanceNotifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
