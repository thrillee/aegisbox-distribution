// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: dlr_forward_queue.sql

package database

import (
	"context"
)

const enqueueDLRForForwarding = `-- name: EnqueueDLRForForwarding :exec
INSERT INTO dlr_forwarding_queue (
    message_id, payload, max_attempts, created_at, status
) VALUES (
    $1, $2, $3, NOW(), 'pending'
)
`

type EnqueueDLRForForwardingParams struct {
	MessageID   int64  `json:"messageId"`
	Payload     []byte `json:"payload"`
	MaxAttempts int32  `json:"maxAttempts"`
}

// Inserts a new DLR forwarding job into the queue.
func (q *Queries) EnqueueDLRForForwarding(ctx context.Context, arg EnqueueDLRForForwardingParams) error {
	_, err := q.db.Exec(ctx, enqueueDLRForForwarding, arg.MessageID, arg.Payload, arg.MaxAttempts)
	return err
}

const getPendingDLRsToForward = `-- name: GetPendingDLRsToForward :many
WITH candidates AS (
    SELECT id
    FROM dlr_forwarding_queue
    WHERE status = 'pending'
      AND (locked_at IS NULL OR locked_at < NOW() - INTERVAL '5 minutes') -- Pick unlocked or stale locks
      AND attempts < max_attempts
    ORDER BY created_at
    LIMIT $1 -- Batch size
    FOR UPDATE SKIP LOCKED
)
UPDATE dlr_forwarding_queue q
SET
    status = 'processing',
    locked_at = NOW(),
    locked_by = $2 -- Worker identifier
FROM candidates c
WHERE q.id = c.id
RETURNING q.id, q.message_id, q.payload, q.attempts, q.max_attempts
`

type GetPendingDLRsToForwardParams struct {
	Limit    int32   `json:"limit"`
	LockedBy *string `json:"lockedBy"`
}

type GetPendingDLRsToForwardRow struct {
	ID          int64  `json:"id"`
	MessageID   int64  `json:"messageId"`
	Payload     []byte `json:"payload"`
	Attempts    int32  `json:"attempts"`
	MaxAttempts int32  `json:"maxAttempts"`
}

// Selects pending DLR jobs and locks them for processing.
func (q *Queries) GetPendingDLRsToForward(ctx context.Context, arg GetPendingDLRsToForwardParams) ([]GetPendingDLRsToForwardRow, error) {
	rows, err := q.db.Query(ctx, getPendingDLRsToForward, arg.Limit, arg.LockedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingDLRsToForwardRow
	for rows.Next() {
		var i GetPendingDLRsToForwardRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.Payload,
			&i.Attempts,
			&i.MaxAttempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingDLRsToForwardWithBackoff = `-- name: GetPendingDLRsToForwardWithBackoff :many
WITH candidates AS (
    SELECT id
    FROM dlr_forwarding_queue
    WHERE status = 'pending'
      AND (next_retry_at IS NULL OR next_retry_at <= NOW())
      AND (locked_at IS NULL OR locked_at < NOW() - INTERVAL '5 minutes')
      AND attempts < max_attempts
    ORDER BY next_retry_at ASC NULLS FIRST, created_at ASC
    LIMIT $1
    FOR UPDATE SKIP LOCKED
)
UPDATE dlr_forwarding_queue q
SET
    status = 'processing',
    locked_at = NOW(),
    locked_by = $2
FROM candidates c
WHERE q.id = c.id
RETURNING q.id, q.message_id, q.payload, q.attempts, q.max_attempts
`

type GetPendingDLRsToForwardWithBackoffParams struct {
	Limit    int32   `json:"limit"`
	LockedBy *string `json:"lockedBy"`
}

type GetPendingDLRsToForwardWithBackoffRow struct {
	ID          int64  `json:"id"`
	MessageID   int64  `json:"messageId"`
	Payload     []byte `json:"payload"`
	Attempts    int32  `json:"attempts"`
	MaxAttempts int32  `json:"maxAttempts"`
}

// Selects pending DLR jobs that are due for retry (next_retry_at <= NOW()).
func (q *Queries) GetPendingDLRsToForwardWithBackoff(ctx context.Context, arg GetPendingDLRsToForwardWithBackoffParams) ([]GetPendingDLRsToForwardWithBackoffRow, error) {
	rows, err := q.db.Query(ctx, getPendingDLRsToForwardWithBackoff, arg.Limit, arg.LockedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingDLRsToForwardWithBackoffRow
	for rows.Next() {
		var i GetPendingDLRsToForwardWithBackoffRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.Payload,
			&i.Attempts,
			&i.MaxAttempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDLRForwardingAttemptFailed = `-- name: MarkDLRForwardingAttemptFailed :exec
UPDATE dlr_forwarding_queue
SET status = CASE WHEN attempts + 1 >= max_attempts THEN 'failed' ELSE 'pending' END,
    attempts = attempts + 1,
    error_message = $1,
    last_attempt_at = NOW(),
    next_retry_at = CASE
        WHEN attempts + 1 >= max_attempts THEN NULL
        ELSE NOW() + (LEAST(GREATEST(5 * (2 ^ attempts), 5), 300) || ' seconds')::interval
    END,
    locked_at = NULL,
    locked_by = NULL
WHERE id = $2
`

type MarkDLRForwardingAttemptFailedParams struct {
	ErrorMessage *string `json:"errorMessage"`
	ID           int64   `json:"id"`
}

// Marks a job as failed for this attempt, increments attempts, sets next_retry_at for exponential backoff.
// Calculates backoff: least(greatest(5 * 2^(attempts), 5 seconds), 5 minutes) seconds
func (q *Queries) MarkDLRForwardingAttemptFailed(ctx context.Context, arg MarkDLRForwardingAttemptFailedParams) error {
	_, err := q.db.Exec(ctx, markDLRForwardingAttemptFailed, arg.ErrorMessage, arg.ID)
	return err
}

const markDLRForwardingSuccess = `-- name: MarkDLRForwardingSuccess :exec
UPDATE dlr_forwarding_queue
SET status = 'success',
    error_message = NULL,
    last_attempt_at = NOW(),
    locked_at = NULL, -- Unlock
    locked_by = NULL
WHERE id = $1
`

// Marks a job as successfully completed.
func (q *Queries) MarkDLRForwardingSuccess(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markDLRForwardingSuccess, id)
	return err
}

const unlockStaleDLRs = `-- name: UnlockStaleDLRs :exec
UPDATE dlr_forwarding_queue
SET status = 'pending',
    locked_at = NULL,
    locked_by = NULL
WHERE status = 'processing'
  AND locked_at < NOW() - INTERVAL '15 minutes'
`

// Optional: Periodically run to unlock jobs held by dead workers.
func (q *Queries) UnlockStaleDLRs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, unlockStaleDLRs)
	return err
}
