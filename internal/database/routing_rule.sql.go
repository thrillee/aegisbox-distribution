// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: routing_rule.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRoutingRules = `-- name: CountRoutingRules :one
SELECT count(*)
FROM routing_rules
WHERE ($1::INT IS NULL OR mno_id = $1)
`

// Counts routing rules, optionally filtered by MNO ID.
func (q *Queries) CountRoutingRules(ctx context.Context, dollar_1 int32) (int64, error) {
	row := q.db.QueryRow(ctx, countRoutingRules, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRoutingRule = `-- name: CreateRoutingRule :one
INSERT INTO routing_rules (
    prefix, mno_id, priority
) VALUES (
    $1, $2, COALESCE($3, 0) -- Default priority to 0 if not provided
) RETURNING id, prefix, mno_id, priority, created_at, updated_at
`

type CreateRoutingRuleParams struct {
	Prefix  string      `json:"prefix"`
	MnoID   int32       `json:"mnoId"`
	Column3 interface{} `json:"column3"`
}

func (q *Queries) CreateRoutingRule(ctx context.Context, arg CreateRoutingRuleParams) (RoutingRule, error) {
	row := q.db.QueryRow(ctx, createRoutingRule, arg.Prefix, arg.MnoID, arg.Column3)
	var i RoutingRule
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.MnoID,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRoutingRule = `-- name: DeleteRoutingRule :exec

DELETE FROM routing_rules WHERE id = $1
`

// Note: If updating mno_id, ensure the new MNO exists (handled by FK or check in handler)
func (q *Queries) DeleteRoutingRule(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRoutingRule, id)
	return err
}

const getRoutingRuleByID = `-- name: GetRoutingRuleByID :one
SELECT rr.id, rr.prefix, rr.mno_id, rr.priority, rr.created_at, rr.updated_at, m.name as mno_name
FROM routing_rules rr
LEFT JOIN mnos m ON rr.mno_id = m.id
WHERE rr.id = $1 LIMIT 1
`

type GetRoutingRuleByIDRow struct {
	ID        int32              `json:"id"`
	Prefix    string             `json:"prefix"`
	MnoID     int32              `json:"mnoId"`
	Priority  int32              `json:"priority"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
	MnoName   *string            `json:"mnoName"`
}

// Join with MNOs to get the name for display
func (q *Queries) GetRoutingRuleByID(ctx context.Context, id int32) (GetRoutingRuleByIDRow, error) {
	row := q.db.QueryRow(ctx, getRoutingRuleByID, id)
	var i GetRoutingRuleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.MnoID,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MnoName,
	)
	return i, err
}

const listRoutingRules = `-- name: ListRoutingRules :many
SELECT rr.id, rr.prefix, rr.mno_id, rr.priority, rr.created_at, rr.updated_at, m.name as mno_name
FROM routing_rules rr
LEFT JOIN mnos m ON rr.mno_id = m.id
WHERE ($1::INT IS NULL OR rr.mno_id = $1) -- Optional MNO ID filter
ORDER BY length(rr.prefix) DESC, rr.priority ASC, rr.id -- Consistent ordering
LIMIT $2 OFFSET $3
`

type ListRoutingRulesParams struct {
	Column1 int32 `json:"column1"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListRoutingRulesRow struct {
	ID        int32              `json:"id"`
	Prefix    string             `json:"prefix"`
	MnoID     int32              `json:"mnoId"`
	Priority  int32              `json:"priority"`
	CreatedAt pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt pgtype.Timestamptz `json:"updatedAt"`
	MnoName   *string            `json:"mnoName"`
}

// Lists routing rules, optionally filtered by MNO ID, with pagination.
func (q *Queries) ListRoutingRules(ctx context.Context, arg ListRoutingRulesParams) ([]ListRoutingRulesRow, error) {
	rows, err := q.db.Query(ctx, listRoutingRules, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRoutingRulesRow
	for rows.Next() {
		var i ListRoutingRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.Prefix,
			&i.MnoID,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MnoName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoutingRule = `-- name: UpdateRoutingRule :one


UPDATE routing_rules
SET
    prefix = COALESCE($1, prefix),
    mno_id = COALESCE($2, mno_id),
    priority = COALESCE($3, priority),
    updated_at = NOW()
WHERE id = $4
RETURNING id, prefix, mno_id, priority, created_at, updated_at
`

type UpdateRoutingRuleParams struct {
	Prefix   *string `json:"prefix"`
	MnoID    *int32  `json:"mnoId"`
	Priority *int32  `json:"priority"`
	ID       int32   `json:"id"`
}

// Optional MNO ID filter
func (q *Queries) UpdateRoutingRule(ctx context.Context, arg UpdateRoutingRuleParams) (RoutingRule, error) {
	row := q.db.QueryRow(ctx, updateRoutingRule,
		arg.Prefix,
		arg.MnoID,
		arg.Priority,
		arg.ID,
	)
	var i RoutingRule
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.MnoID,
		&i.Priority,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
