// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: otp_templates.sql

package database

import (
	"context"
)

const countOtpMessageTemplates = `-- name: CountOtpMessageTemplates :one
SELECT count(*)
FROM otp_message_templates
WHERE ($1::VARCHAR IS NULL OR status = $1::VARCHAR)
`

func (q *Queries) CountOtpMessageTemplates(ctx context.Context, status *string) (int64, error) {
	row := q.db.QueryRow(ctx, countOtpMessageTemplates, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOtpMessageTemplate = `-- name: CreateOtpMessageTemplate :one

INSERT INTO otp_message_templates (
    name,
    content_template,
    default_brand_name,
    status
) VALUES (
    $1, $2, $3, $4
) RETURNING id, name, content_template, default_brand_name, status, created_at, updated_at
`

type CreateOtpMessageTemplateParams struct {
	Name             string  `json:"name"`
	ContentTemplate  string  `json:"contentTemplate"`
	DefaultBrandName *string `json:"defaultBrandName"`
	Status           string  `json:"status"`
}

// Then by priority of assignment
func (q *Queries) CreateOtpMessageTemplate(ctx context.Context, arg CreateOtpMessageTemplateParams) (OtpMessageTemplate, error) {
	row := q.db.QueryRow(ctx, createOtpMessageTemplate,
		arg.Name,
		arg.ContentTemplate,
		arg.DefaultBrandName,
		arg.Status,
	)
	var i OtpMessageTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContentTemplate,
		&i.DefaultBrandName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOtpMessageTemplate = `-- name: DeleteOtpMessageTemplate :exec
DELETE FROM otp_message_templates WHERE id = $1
`

func (q *Queries) DeleteOtpMessageTemplate(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOtpMessageTemplate, id)
	return err
}

const getOtpMessageTemplateByID = `-- name: GetOtpMessageTemplateByID :one
SELECT id, name, content_template, default_brand_name, status, created_at, updated_at FROM otp_message_templates
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOtpMessageTemplateByID(ctx context.Context, id int32) (OtpMessageTemplate, error) {
	row := q.db.QueryRow(ctx, getOtpMessageTemplateByID, id)
	var i OtpMessageTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContentTemplate,
		&i.DefaultBrandName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAlternativeSendersWithAssignedTemplates = `-- name: ListAlternativeSendersWithAssignedTemplates :many
SELECT
    oas.id AS alternative_sender_id,
    oas.sender_id_string,
    oas.status AS alternative_sender_status,
    oas.mno_id AS sender_mno_id, -- MNO ID of the alternative sender itself
    sender_mno.name AS sender_mno_name,
    oas.service_provider_id AS sender_service_provider_id,
    sp.name AS sender_service_provider_name,
    osta.id AS assignment_id, -- Nullable if no active assignment/template
    osta.status AS assignment_status, -- Nullable
    osta.priority AS assignment_priority, -- Nullable
    osta.mno_id AS assignment_mno_id, -- MNO ID specific to the assignment (can be different from sender's MNO or NULL)
    assignment_mno.name AS assignment_mno_name, -- Nullable
    omt.id AS template_id, -- Nullable
    omt.name AS template_name -- Nullable
FROM otp_alternative_senders oas
LEFT JOIN mnos sender_mno ON oas.mno_id = sender_mno.id
LEFT JOIN service_providers sp ON oas.service_provider_id = sp.id
LEFT JOIN otp_sender_template_assignments osta
    ON oas.id = osta.otp_alternative_sender_id AND osta.status = 'active'
LEFT JOIN otp_message_templates omt
    ON osta.otp_message_template_id = omt.id AND omt.status = 'active'
LEFT JOIN mnos assignment_mno ON osta.mno_id = assignment_mno.id
WHERE
    oas.status = 'active' -- Consider if you want to filter alternative senders by status here, or show all and their assignment statuses.
AND ($1::VARCHAR IS NULL OR oas.sender_id_string = $1::VARCHAR)
AND ($2::INT IS NULL OR oas.service_provider_id = $2::INT)
ORDER BY
    oas.sender_id_string ASC, -- Group by sender
    osta.mno_id ASC NULLS FIRST, -- Order assignments for a sender: MNO-agnostic first, then by MNO ID
    osta.priority ASC
`

type ListAlternativeSendersWithAssignedTemplatesParams struct {
	FilterSenderIDString    *string `json:"filterSenderIdString"`
	FilterServiceProviderID *int32  `json:"filterServiceProviderId"`
}

type ListAlternativeSendersWithAssignedTemplatesRow struct {
	AlternativeSenderID       int32   `json:"alternativeSenderId"`
	SenderIDString            string  `json:"senderIdString"`
	AlternativeSenderStatus   string  `json:"alternativeSenderStatus"`
	SenderMnoID               *int32  `json:"senderMnoId"`
	SenderMnoName             *string `json:"senderMnoName"`
	SenderServiceProviderID   *int32  `json:"senderServiceProviderId"`
	SenderServiceProviderName *string `json:"senderServiceProviderName"`
	AssignmentID              *int32  `json:"assignmentId"`
	AssignmentStatus          *string `json:"assignmentStatus"`
	AssignmentPriority        *int32  `json:"assignmentPriority"`
	AssignmentMnoID           *int32  `json:"assignmentMnoId"`
	AssignmentMnoName         *string `json:"assignmentMnoName"`
	TemplateID                *int32  `json:"templateId"`
	TemplateName              *string `json:"templateName"`
}

func (q *Queries) ListAlternativeSendersWithAssignedTemplates(ctx context.Context, arg ListAlternativeSendersWithAssignedTemplatesParams) ([]ListAlternativeSendersWithAssignedTemplatesRow, error) {
	rows, err := q.db.Query(ctx, listAlternativeSendersWithAssignedTemplates, arg.FilterSenderIDString, arg.FilterServiceProviderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAlternativeSendersWithAssignedTemplatesRow
	for rows.Next() {
		var i ListAlternativeSendersWithAssignedTemplatesRow
		if err := rows.Scan(
			&i.AlternativeSenderID,
			&i.SenderIDString,
			&i.AlternativeSenderStatus,
			&i.SenderMnoID,
			&i.SenderMnoName,
			&i.SenderServiceProviderID,
			&i.SenderServiceProviderName,
			&i.AssignmentID,
			&i.AssignmentStatus,
			&i.AssignmentPriority,
			&i.AssignmentMnoID,
			&i.AssignmentMnoName,
			&i.TemplateID,
			&i.TemplateName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOtpMessageTemplates = `-- name: ListOtpMessageTemplates :many
SELECT id, name, content_template, default_brand_name, status, created_at, updated_at
FROM otp_message_templates
WHERE ($1::VARCHAR IS NULL OR status = $1::VARCHAR)
ORDER BY name ASC
LIMIT $3::INT
OFFSET $2::INT
`

type ListOtpMessageTemplatesParams struct {
	Status    *string `json:"status"`
	OffsetVal int32   `json:"offsetVal"`
	LimitVal  int32   `json:"limitVal"`
}

func (q *Queries) ListOtpMessageTemplates(ctx context.Context, arg ListOtpMessageTemplatesParams) ([]OtpMessageTemplate, error) {
	rows, err := q.db.Query(ctx, listOtpMessageTemplates, arg.Status, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OtpMessageTemplate
	for rows.Next() {
		var i OtpMessageTemplate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContentTemplate,
			&i.DefaultBrandName,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOtpMessageTemplate = `-- name: UpdateOtpMessageTemplate :one
UPDATE otp_message_templates
SET
    name = COALESCE($1, name),
    content_template = COALESCE($2, content_template),
    default_brand_name = COALESCE($3, default_brand_name),
    status = COALESCE($4, status),
    updated_at = NOW()
WHERE id = $5
RETURNING id, name, content_template, default_brand_name, status, created_at, updated_at
`

type UpdateOtpMessageTemplateParams struct {
	Name             *string `json:"name"`
	ContentTemplate  *string `json:"contentTemplate"`
	DefaultBrandName *string `json:"defaultBrandName"`
	Status           *string `json:"status"`
	ID               int32   `json:"id"`
}

func (q *Queries) UpdateOtpMessageTemplate(ctx context.Context, arg UpdateOtpMessageTemplateParams) (OtpMessageTemplate, error) {
	row := q.db.QueryRow(ctx, updateOtpMessageTemplate,
		arg.Name,
		arg.ContentTemplate,
		arg.DefaultBrandName,
		arg.Status,
		arg.ID,
	)
	var i OtpMessageTemplate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContentTemplate,
		&i.DefaultBrandName,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
