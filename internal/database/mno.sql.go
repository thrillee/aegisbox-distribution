// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: mno.sql

package database

import (
	"context"
)

const countMNOs = `-- name: CountMNOs :one
SELECT count(*) FROM mnos
`

func (q *Queries) CountMNOs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMNOs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMNO = `-- name: CreateMNO :one
INSERT INTO mnos (
    name, country_code, network_code, status
) VALUES (
    $1, $2, $3, COALESCE($4, 'active') -- Use input status or default to 'active'
) RETURNING id, name, country_code, network_code, status, created_at, updated_at
`

type CreateMNOParams struct {
	Name        string      `json:"name"`
	CountryCode string      `json:"countryCode"`
	NetworkCode *string     `json:"networkCode"`
	Column4     interface{} `json:"column4"`
}

func (q *Queries) CreateMNO(ctx context.Context, arg CreateMNOParams) (Mno, error) {
	row := q.db.QueryRow(ctx, createMNO,
		arg.Name,
		arg.CountryCode,
		arg.NetworkCode,
		arg.Column4,
	)
	var i Mno
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryCode,
		&i.NetworkCode,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateMNO = `-- name: DeactivateMNO :one
UPDATE mnos SET status = 'inactive', updated_at = NOW() WHERE id = $1 RETURNING id, name, country_code, network_code, status, created_at, updated_at
`

// Optional: Query to set MNO status to inactive instead of deleting
func (q *Queries) DeactivateMNO(ctx context.Context, id int32) (Mno, error) {
	row := q.db.QueryRow(ctx, deactivateMNO, id)
	var i Mno
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryCode,
		&i.NetworkCode,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMNO = `-- name: DeleteMNO :exec
DELETE FROM mnos WHERE id = $1
`

// Consider consequences - deletes might fail if MNO is referenced by connections/rules (ON DELETE RESTRICT)
// It might be safer to just set status to 'inactive'.
func (q *Queries) DeleteMNO(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMNO, id)
	return err
}

const getMNOByID = `-- name: GetMNOByID :one
SELECT id, name, country_code, network_code, status, created_at, updated_at FROM mnos WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMNOByID(ctx context.Context, id int32) (Mno, error) {
	row := q.db.QueryRow(ctx, getMNOByID, id)
	var i Mno
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryCode,
		&i.NetworkCode,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMNOs = `-- name: ListMNOs :many
SELECT id, name, country_code, network_code, status, created_at, updated_at FROM mnos
ORDER BY name -- Or country_code, name
LIMIT $1 OFFSET $2
`

type ListMNOsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMNOs(ctx context.Context, arg ListMNOsParams) ([]Mno, error) {
	rows, err := q.db.Query(ctx, listMNOs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mno
	for rows.Next() {
		var i Mno
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CountryCode,
			&i.NetworkCode,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMNO = `-- name: UpdateMNO :one
UPDATE mnos
SET
    name = COALESCE($1, name),
    country_code = COALESCE($2, country_code),
    network_code = $3, -- Allow setting network_code to NULL
    status = COALESCE($4, status),
    updated_at = NOW()
WHERE id = $5
RETURNING id, name, country_code, network_code, status, created_at, updated_at
`

type UpdateMNOParams struct {
	Name        *string `json:"name"`
	CountryCode *string `json:"countryCode"`
	NetworkCode *string `json:"networkCode"`
	Status      *string `json:"status"`
	ID          int32   `json:"id"`
}

func (q *Queries) UpdateMNO(ctx context.Context, arg UpdateMNOParams) (Mno, error) {
	row := q.db.QueryRow(ctx, updateMNO,
		arg.Name,
		arg.CountryCode,
		arg.NetworkCode,
		arg.Status,
		arg.ID,
	)
	var i Mno
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CountryCode,
		&i.NetworkCode,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
