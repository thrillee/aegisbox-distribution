// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: otp_alternative_senders.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOtpAlternativeSenders = `-- name: CountOtpAlternativeSenders :one
SELECT count(*)
FROM otp_alternative_senders
WHERE
    ($1::VARCHAR IS NULL OR status = $1::VARCHAR)
AND ($2::INT IS NULL OR mno_id = $2::INT)
AND (
        ($3::INT IS NOT NULL AND service_provider_id = $3::INT) OR
        ($3::INT IS NULL AND $4::BOOLEAN = TRUE AND service_provider_id IS NULL) OR
        ($3::INT IS NULL AND $4::BOOLEAN = FALSE)
    )
`

type CountOtpAlternativeSendersParams struct {
	Status              *string `json:"status"`
	MnoID               *int32  `json:"mnoId"`
	ServiceProviderID   *int32  `json:"serviceProviderId"`
	IncludeGlobalSpNull *bool   `json:"includeGlobalSpNull"`
}

func (q *Queries) CountOtpAlternativeSenders(ctx context.Context, arg CountOtpAlternativeSendersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOtpAlternativeSenders,
		arg.Status,
		arg.MnoID,
		arg.ServiceProviderID,
		arg.IncludeGlobalSpNull,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOtpAlternativeSender = `-- name: CreateOtpAlternativeSender :one


INSERT INTO otp_alternative_senders (
    sender_id_string,
    mno_id,
    service_provider_id,
    status,
    max_usage_count,
    current_usage_count, -- Allow setting initial count if needed
    reset_interval_hours,
    last_reset_at,
    notes
) VALUES (
    $1, $2, $3, $4, $5, COALESCE($8, 0), $6, COALESCE($9, NOW()), $7
) RETURNING id, sender_id_string, service_provider_id, mno_id, status, current_usage_count, max_usage_count, reset_interval_hours, last_reset_at, last_used_at, notes, created_at, updated_at
`

type CreateOtpAlternativeSenderParams struct {
	SenderIDString     string      `json:"senderIdString"`
	MnoID              *int32      `json:"mnoId"`
	ServiceProviderID  *int32      `json:"serviceProviderId"`
	Status             string      `json:"status"`
	MaxUsageCount      int32       `json:"maxUsageCount"`
	ResetIntervalHours *int32      `json:"resetIntervalHours"`
	Notes              *string     `json:"notes"`
	CurrentUsageCount  interface{} `json:"currentUsageCount"`
	LastResetAt        interface{} `json:"lastResetAt"`
}

// Limit how many to fetch for selection in code
func (q *Queries) CreateOtpAlternativeSender(ctx context.Context, arg CreateOtpAlternativeSenderParams) (OtpAlternativeSender, error) {
	row := q.db.QueryRow(ctx, createOtpAlternativeSender,
		arg.SenderIDString,
		arg.MnoID,
		arg.ServiceProviderID,
		arg.Status,
		arg.MaxUsageCount,
		arg.ResetIntervalHours,
		arg.Notes,
		arg.CurrentUsageCount,
		arg.LastResetAt,
	)
	var i OtpAlternativeSender
	err := row.Scan(
		&i.ID,
		&i.SenderIDString,
		&i.ServiceProviderID,
		&i.MnoID,
		&i.Status,
		&i.CurrentUsageCount,
		&i.MaxUsageCount,
		&i.ResetIntervalHours,
		&i.LastResetAt,
		&i.LastUsedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOtpAlternativeSender = `-- name: DeleteOtpAlternativeSender :exec
DELETE FROM otp_alternative_senders WHERE id = $1
`

func (q *Queries) DeleteOtpAlternativeSender(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteOtpAlternativeSender, id)
	return err
}

const getOtpAlternativeSenderByID = `-- name: GetOtpAlternativeSenderByID :one
SELECT
    oas.id, oas.sender_id_string, oas.service_provider_id, oas.mno_id, oas.status, oas.current_usage_count, oas.max_usage_count, oas.reset_interval_hours, oas.last_reset_at, oas.last_used_at, oas.notes, oas.created_at, oas.updated_at,
    m.name AS mno_name,
    sp.name AS service_provider_name
FROM otp_alternative_senders oas
LEFT JOIN mnos m ON oas.mno_id = m.id
LEFT JOIN service_providers sp ON oas.service_provider_id = sp.id
WHERE oas.id = $1 LIMIT 1
`

type GetOtpAlternativeSenderByIDRow struct {
	ID                  int32              `json:"id"`
	SenderIDString      string             `json:"senderIdString"`
	ServiceProviderID   *int32             `json:"serviceProviderId"`
	MnoID               *int32             `json:"mnoId"`
	Status              string             `json:"status"`
	CurrentUsageCount   int32              `json:"currentUsageCount"`
	MaxUsageCount       int32              `json:"maxUsageCount"`
	ResetIntervalHours  *int32             `json:"resetIntervalHours"`
	LastResetAt         pgtype.Timestamptz `json:"lastResetAt"`
	LastUsedAt          pgtype.Timestamptz `json:"lastUsedAt"`
	Notes               *string            `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt           pgtype.Timestamptz `json:"updatedAt"`
	MnoName             *string            `json:"mnoName"`
	ServiceProviderName *string            `json:"serviceProviderName"`
}

func (q *Queries) GetOtpAlternativeSenderByID(ctx context.Context, id int32) (GetOtpAlternativeSenderByIDRow, error) {
	row := q.db.QueryRow(ctx, getOtpAlternativeSenderByID, id)
	var i GetOtpAlternativeSenderByIDRow
	err := row.Scan(
		&i.ID,
		&i.SenderIDString,
		&i.ServiceProviderID,
		&i.MnoID,
		&i.Status,
		&i.CurrentUsageCount,
		&i.MaxUsageCount,
		&i.ResetIntervalHours,
		&i.LastResetAt,
		&i.LastUsedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MnoName,
		&i.ServiceProviderName,
	)
	return i, err
}

const incrementOtpAlternativeSenderUsage = `-- name: IncrementOtpAlternativeSenderUsage :one
UPDATE otp_alternative_senders
SET
    current_usage_count = current_usage_count + 1,
    last_used_at = NOW()
WHERE id = $1
RETURNING id, sender_id_string, service_provider_id, mno_id, status, current_usage_count, max_usage_count, reset_interval_hours, last_reset_at, last_used_at, notes, created_at, updated_at
`

func (q *Queries) IncrementOtpAlternativeSenderUsage(ctx context.Context, id int32) (OtpAlternativeSender, error) {
	row := q.db.QueryRow(ctx, incrementOtpAlternativeSenderUsage, id)
	var i OtpAlternativeSender
	err := row.Scan(
		&i.ID,
		&i.SenderIDString,
		&i.ServiceProviderID,
		&i.MnoID,
		&i.Status,
		&i.CurrentUsageCount,
		&i.MaxUsageCount,
		&i.ResetIntervalHours,
		&i.LastResetAt,
		&i.LastUsedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listGlobalOtpAlternativeSenders = `-- name: ListGlobalOtpAlternativeSenders :many
SELECT id, sender_id_string, service_provider_id, mno_id, status, current_usage_count, max_usage_count, reset_interval_hours, last_reset_at, last_used_at, notes, created_at, updated_at
FROM otp_alternative_senders
WHERE status = 'active'
  AND current_usage_count < max_usage_count
  AND (mno_id = $2 OR ($2 IS NULL AND mno_id IS NULL)) -- Matches specific MNO or global
ORDER BY last_used_at ASC NULLS FIRST, id ASC -- Prioritize those never used or least recently used
LIMIT $1
`

type ListGlobalOtpAlternativeSendersParams struct {
	Limit int32  `json:"limit"`
	MnoID *int32 `json:"mnoId"`
}

// Selects active senders that are not depleted, optionally for a specific MNO or global ones (MNO ID IS NULL).
// Orders by least recently used to attempt rotation.
func (q *Queries) ListGlobalOtpAlternativeSenders(ctx context.Context, arg ListGlobalOtpAlternativeSendersParams) ([]OtpAlternativeSender, error) {
	rows, err := q.db.Query(ctx, listGlobalOtpAlternativeSenders, arg.Limit, arg.MnoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OtpAlternativeSender
	for rows.Next() {
		var i OtpAlternativeSender
		if err := rows.Scan(
			&i.ID,
			&i.SenderIDString,
			&i.ServiceProviderID,
			&i.MnoID,
			&i.Status,
			&i.CurrentUsageCount,
			&i.MaxUsageCount,
			&i.ResetIntervalHours,
			&i.LastResetAt,
			&i.LastUsedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOtpAlternativeSenders = `-- name: ListOtpAlternativeSenders :many
SELECT
    oas.id, oas.sender_id_string, oas.service_provider_id, oas.mno_id, oas.status, oas.current_usage_count, oas.max_usage_count, oas.reset_interval_hours, oas.last_reset_at, oas.last_used_at, oas.notes, oas.created_at, oas.updated_at,
    m.name AS mno_name,
    sp.name AS service_provider_name
FROM otp_alternative_senders oas
LEFT JOIN mnos m ON oas.mno_id = m.id
LEFT JOIN service_providers sp ON oas.service_provider_id = sp.id
WHERE
    ($1::VARCHAR IS NULL OR oas.status = $1::VARCHAR)
AND ($2::INT IS NULL OR oas.mno_id = $2::INT)
AND (
        ($3::INT IS NOT NULL AND oas.service_provider_id = $3::INT) OR
        ($3::INT IS NULL AND $4::BOOLEAN = TRUE AND oas.service_provider_id IS NULL) OR
        ($3::INT IS NULL AND $4::BOOLEAN = FALSE) -- if sp_id not given and not including global, effectively no filter on sp_id
    )
ORDER BY oas.id DESC -- Or other preferred order
LIMIT $6::INT
OFFSET $5::INT
`

type ListOtpAlternativeSendersParams struct {
	Status              *string `json:"status"`
	MnoID               *int32  `json:"mnoId"`
	ServiceProviderID   *int32  `json:"serviceProviderId"`
	IncludeGlobalSpNull *bool   `json:"includeGlobalSpNull"`
	OffsetVal           int32   `json:"offsetVal"`
	LimitVal            int32   `json:"limitVal"`
}

type ListOtpAlternativeSendersRow struct {
	ID                  int32              `json:"id"`
	SenderIDString      string             `json:"senderIdString"`
	ServiceProviderID   *int32             `json:"serviceProviderId"`
	MnoID               *int32             `json:"mnoId"`
	Status              string             `json:"status"`
	CurrentUsageCount   int32              `json:"currentUsageCount"`
	MaxUsageCount       int32              `json:"maxUsageCount"`
	ResetIntervalHours  *int32             `json:"resetIntervalHours"`
	LastResetAt         pgtype.Timestamptz `json:"lastResetAt"`
	LastUsedAt          pgtype.Timestamptz `json:"lastUsedAt"`
	Notes               *string            `json:"notes"`
	CreatedAt           pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt           pgtype.Timestamptz `json:"updatedAt"`
	MnoName             *string            `json:"mnoName"`
	ServiceProviderName *string            `json:"serviceProviderName"`
}

func (q *Queries) ListOtpAlternativeSenders(ctx context.Context, arg ListOtpAlternativeSendersParams) ([]ListOtpAlternativeSendersRow, error) {
	rows, err := q.db.Query(ctx, listOtpAlternativeSenders,
		arg.Status,
		arg.MnoID,
		arg.ServiceProviderID,
		arg.IncludeGlobalSpNull,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOtpAlternativeSendersRow
	for rows.Next() {
		var i ListOtpAlternativeSendersRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderIDString,
			&i.ServiceProviderID,
			&i.MnoID,
			&i.Status,
			&i.CurrentUsageCount,
			&i.MaxUsageCount,
			&i.ResetIntervalHours,
			&i.LastResetAt,
			&i.LastUsedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MnoName,
			&i.ServiceProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpSpecificOtpAlternativeSenders = `-- name: ListSpSpecificOtpAlternativeSenders :many
SELECT id, sender_id_string, service_provider_id, mno_id, status, current_usage_count, max_usage_count, reset_interval_hours, last_reset_at, last_used_at, notes, created_at, updated_at
FROM otp_alternative_senders
WHERE service_provider_id = $1 -- Required: service_provider_id
  AND status = 'active'
  AND current_usage_count < max_usage_count
  AND (mno_id = $3 OR ($3 IS NULL AND mno_id IS NULL))
ORDER BY last_used_at ASC NULLS FIRST, id ASC -- Rotate by least recently used
LIMIT $2
`

type ListSpSpecificOtpAlternativeSendersParams struct {
	ServiceProviderID *int32 `json:"serviceProviderId"`
	Limit             int32  `json:"limit"`
	MnoID             *int32 `json:"mnoId"`
}

// Selects Service Provider-specific, active senders that are not depleted.
// Can filter by a specific MNO (if $2 is not NULL) OR select SP-specific senders that are MNO-agnostic (sender.mno_id IS NULL, if $2 is NULL).
func (q *Queries) ListSpSpecificOtpAlternativeSenders(ctx context.Context, arg ListSpSpecificOtpAlternativeSendersParams) ([]OtpAlternativeSender, error) {
	rows, err := q.db.Query(ctx, listSpSpecificOtpAlternativeSenders, arg.ServiceProviderID, arg.Limit, arg.MnoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OtpAlternativeSender
	for rows.Next() {
		var i OtpAlternativeSender
		if err := rows.Scan(
			&i.ID,
			&i.SenderIDString,
			&i.ServiceProviderID,
			&i.MnoID,
			&i.Status,
			&i.CurrentUsageCount,
			&i.MaxUsageCount,
			&i.ResetIntervalHours,
			&i.LastResetAt,
			&i.LastUsedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOtpAlternativeSender = `-- name: UpdateOtpAlternativeSender :one
UPDATE otp_alternative_senders
SET
    sender_id_string = COALESCE($1, sender_id_string),
    mno_id = CASE
                WHEN $2::BOOLEAN = TRUE THEN NULL
                ELSE COALESCE($3, mno_id)
             END,
    service_provider_id = CASE
                            WHEN $4::BOOLEAN = TRUE THEN NULL
                            ELSE COALESCE($5, service_provider_id)
                          END,
    status = COALESCE($6, status),
    max_usage_count = COALESCE($7, max_usage_count),
    current_usage_count = COALESCE($8, current_usage_count),
    reset_interval_hours = COALESCE($9, reset_interval_hours),
    last_reset_at = COALESCE($10, last_reset_at),
    notes = COALESCE($11, notes),
    updated_at = NOW()
WHERE id = $12
RETURNING id, sender_id_string, service_provider_id, mno_id, status, current_usage_count, max_usage_count, reset_interval_hours, last_reset_at, last_used_at, notes, created_at, updated_at
`

type UpdateOtpAlternativeSenderParams struct {
	SenderIDString         *string            `json:"senderIdString"`
	ClearMnoID             *bool              `json:"clearMnoId"`
	MnoID                  *int32             `json:"mnoId"`
	ClearServiceProviderID *bool              `json:"clearServiceProviderId"`
	ServiceProviderID      *int32             `json:"serviceProviderId"`
	Status                 *string            `json:"status"`
	MaxUsageCount          *int32             `json:"maxUsageCount"`
	CurrentUsageCount      *int32             `json:"currentUsageCount"`
	ResetIntervalHours     *int32             `json:"resetIntervalHours"`
	LastResetAt            pgtype.Timestamptz `json:"lastResetAt"`
	Notes                  *string            `json:"notes"`
	ID                     int32              `json:"id"`
}

func (q *Queries) UpdateOtpAlternativeSender(ctx context.Context, arg UpdateOtpAlternativeSenderParams) (OtpAlternativeSender, error) {
	row := q.db.QueryRow(ctx, updateOtpAlternativeSender,
		arg.SenderIDString,
		arg.ClearMnoID,
		arg.MnoID,
		arg.ClearServiceProviderID,
		arg.ServiceProviderID,
		arg.Status,
		arg.MaxUsageCount,
		arg.CurrentUsageCount,
		arg.ResetIntervalHours,
		arg.LastResetAt,
		arg.Notes,
		arg.ID,
	)
	var i OtpAlternativeSender
	err := row.Scan(
		&i.ID,
		&i.SenderIDString,
		&i.ServiceProviderID,
		&i.MnoID,
		&i.Status,
		&i.CurrentUsageCount,
		&i.MaxUsageCount,
		&i.ResetIntervalHours,
		&i.LastResetAt,
		&i.LastUsedAt,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
